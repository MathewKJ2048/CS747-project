Require Import Ensembles.


(* Countably Infinite number of states *)

Print nat.

Inductive State : Type :=
  | St (n1 : nat).

Check St 0.
Check St 1.

Fixpoint eq (a b : nat): bool :=
match a with
| 0 => match b with | 0 => true | S n => false end
| S m => match b with | 0 => false | S n => eq m n end
end.

Definition eq_st (s1 s2 : State) : bool := 
match s1, s2 with
| St m, St n => eq m n
end.

Theorem self_equality:
forall n, eq_st (St n) (St n) = true.
Proof.
intros.
simpl.
induction n.
reflexivity.
simpl.
apply IHn.
Qed.

Inductive Transition : Type :=
| TS : State -> State -> Transition.

Check TS (St 1) (St 2).

(*
	Kripke:
	set of states, set of transitions, set of initial states, all states must have at least one out-transition
*)

Inductive State_machine : Type :=
| SM : State -> Ensemble Transition -> State_machine.


Inductive Trace : Type :=
| Tr : State -> Trace -> Trace
| Null.
(*
	omega-word in S, temporarily considered finite
	with finite traces, only safety can be guaranteed, not liveness
*)

Definition next(transitions : Ensemble Transition)(s : State): State :=
s.

Fixpoint valid(sm : State_machine)( t : Trace): bool :=
match sm, t with
| SM is x, Tr s y => andb (eq_st is s) 
	(valid (SM (next x is) x) (y))
| _ , Null => true
end.
(*
	is true if the given trace is generated by the State machine, false otherwise
*)

(*
	Safety: forall traces: S in trace => not valid for SM
	is saying S is never reached by the SM
	proof in alternate direction:
	valid => not S in trace may be easier to prove
*)




